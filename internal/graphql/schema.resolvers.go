package graphql

// Code generated by github.com/99designs/gqlgen version v0.17.86
// Resolver implementations below are hand-written.

import (
	"context"
	"time"

	"github.com/persistorai/persistor/internal/models"
)

// CreateNode is the resolver for the createNode field.
func (r *mutationResolver) CreateNode(ctx context.Context, input CreateNodeInput) (*Node, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	req := models.CreateNodeRequest{
		ID:         derefStr(input.ID),
		Type:       input.Type,
		Label:      input.Label,
		Properties: input.Properties,
	}
	if err := req.Validate(); err != nil {
		return nil, gqlErr(ctx, err)
	}
	n, err := r.NodeSvc.CreateNode(ctx, tid, req)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodeToGQL(n), nil
}

// UpdateNode is the resolver for the updateNode field.
func (r *mutationResolver) UpdateNode(ctx context.Context, id string, input UpdateNodeInput) (*Node, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	req := models.UpdateNodeRequest{
		Type:       input.Type,
		Label:      input.Label,
		Properties: input.Properties,
	}
	if err := req.Validate(); err != nil {
		return nil, gqlErr(ctx, err)
	}
	n, err := r.NodeSvc.UpdateNode(ctx, tid, id, req)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodeToGQL(n), nil
}

// DeleteNode is the resolver for the deleteNode field.
func (r *mutationResolver) DeleteNode(ctx context.Context, id string) (bool, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return false, gqlErr(ctx, err)
	}
	if err := r.NodeSvc.DeleteNode(ctx, tid, id); err != nil {
		return false, gqlErr(ctx, err)
	}
	return true, nil
}

// CreateEdge is the resolver for the createEdge field.
func (r *mutationResolver) CreateEdge(ctx context.Context, input CreateEdgeInput) (*Edge, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	req := models.CreateEdgeRequest{
		Source:     input.Source,
		Target:     input.Target,
		Relation:   input.Relation,
		Properties: input.Properties,
		Weight:     input.Weight,
	}
	if err := req.Validate(); err != nil {
		return nil, gqlErr(ctx, err)
	}
	e, err := r.EdgeStore.CreateEdge(ctx, tid, req)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return edgeToGQL(e), nil
}

// UpdateEdge is the resolver for the updateEdge field.
func (r *mutationResolver) UpdateEdge(ctx context.Context, source string, target string, relation string, input UpdateEdgeInput) (*Edge, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	req := models.UpdateEdgeRequest{
		Properties: input.Properties,
		Weight:     input.Weight,
	}
	if err := req.Validate(); err != nil {
		return nil, gqlErr(ctx, err)
	}
	e, err := r.EdgeStore.UpdateEdge(ctx, tid, source, target, relation, req)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return edgeToGQL(e), nil
}

// DeleteEdge is the resolver for the deleteEdge field.
func (r *mutationResolver) DeleteEdge(ctx context.Context, source string, target string, relation string) (bool, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return false, gqlErr(ctx, err)
	}
	if err := r.EdgeStore.DeleteEdge(ctx, tid, source, target, relation); err != nil {
		return false, gqlErr(ctx, err)
	}
	return true, nil
}

// BoostNode is the resolver for the boostNode field.
func (r *mutationResolver) BoostNode(ctx context.Context, id string) (*Node, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	n, err := r.SalienceSvc.BoostNode(ctx, tid, id)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodeToGQL(n), nil
}

// SupersedeNode is the resolver for the supersedeNode field.
func (r *mutationResolver) SupersedeNode(ctx context.Context, oldID string, newID string) (bool, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return false, gqlErr(ctx, err)
	}
	if err := r.SalienceSvc.SupersedeNode(ctx, tid, oldID, newID); err != nil {
		return false, gqlErr(ctx, err)
	}
	return true, nil
}

// RecalculateSalience is the resolver for the recalculateSalience field.
func (r *mutationResolver) RecalculateSalience(ctx context.Context) (int, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return 0, gqlErr(ctx, err)
	}
	count, err := r.SalienceSvc.RecalculateSalience(ctx, tid)
	if err != nil {
		return 0, gqlErr(ctx, err)
	}
	return count, nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (*Node, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	n, err := r.NodeSvc.GetNode(ctx, tid, id)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodeToGQL(n), nil
}

// Nodes is the resolver for the nodes field.
func (r *queryResolver) Nodes(ctx context.Context, typeArg *string, minSalience *float64, limit *int, offset *int) (*NodeConnection, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	nodes, hasMore, err := r.NodeSvc.ListNodes(ctx, tid, derefStr(typeArg), deref(minSalience, 0.0), deref(limit, 50), deref(offset, 0))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &NodeConnection{Nodes: nodesToGQL(nodes), HasMore: hasMore}, nil
}

// Edges is the resolver for the edges field.
func (r *queryResolver) Edges(ctx context.Context, source *string, target *string, relation *string, limit *int, offset *int) (*EdgeConnection, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	edges, hasMore, err := r.EdgeStore.ListEdges(ctx, tid, derefStr(source), derefStr(target), derefStr(relation), deref(limit, 50), deref(offset, 0))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &EdgeConnection{Edges: edgesToGQL(edges), HasMore: hasMore}, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, limit *int) ([]*SearchResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	nodes, err := r.SearchSvc.FullTextSearch(ctx, tid, query, "", 0, deref(limit, 20))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodesToSearchResults(nodes), nil
}

// SearchSemantic is the resolver for the searchSemantic field.
func (r *queryResolver) SearchSemantic(ctx context.Context, query string, limit *int) ([]*SearchResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	scored, err := r.SearchSvc.SemanticSearch(ctx, tid, query, deref(limit, 20))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return scoredNodesToSearchResults(scored), nil
}

// SearchHybrid is the resolver for the searchHybrid field.
func (r *queryResolver) SearchHybrid(ctx context.Context, query string, limit *int) ([]*SearchResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	nodes, err := r.SearchSvc.HybridSearch(ctx, tid, query, deref(limit, 20))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodesToSearchResults(nodes), nil
}

// Neighbors is the resolver for the neighbors field.
func (r *queryResolver) Neighbors(ctx context.Context, id string, limit *int) (*NeighborResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	result, err := r.GraphStore.Neighbors(ctx, tid, id, deref(limit, 50))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &NeighborResult{Nodes: nodesToGQL(result.Nodes), Edges: edgesToGQL(result.Edges)}, nil
}

// Traverse is the resolver for the traverse field.
func (r *queryResolver) Traverse(ctx context.Context, id string, maxHops *int) (*TraverseResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	result, err := r.GraphStore.Traverse(ctx, tid, id, deref(maxHops, 2))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &TraverseResult{Nodes: nodesToGQL(result.Nodes), Edges: edgesToGQL(result.Edges)}, nil
}

// Context is the resolver for the context field.
func (r *queryResolver) Context(ctx context.Context, id string) (*ContextResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	result, err := r.GraphStore.GraphContext(ctx, tid, id)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &ContextResult{
		Node:      nodeToGQL(&result.Node),
		Neighbors: nodesToGQL(result.Neighbors),
		Edges:     edgesToGQL(result.Edges),
	}, nil
}

// Path is the resolver for the path field.
func (r *queryResolver) Path(ctx context.Context, from string, to string) ([]*Node, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	nodes, err := r.GraphStore.ShortestPath(ctx, tid, from, to)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodesToGQL(nodes), nil
}

// Audit is the resolver for the audit field.
func (r *queryResolver) Audit(ctx context.Context, entityType *string, entityID *string, action *string, since *string, limit *int, offset *int) (*AuditConnection, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	opts := models.AuditQueryOpts{
		EntityType: derefStr(entityType),
		EntityID:   derefStr(entityID),
		Action:     derefStr(action),
		Limit:      deref(limit, 50),
		Offset:     deref(offset, 0),
	}
	if since != nil {
		t, parseErr := time.Parse(time.RFC3339, *since)
		if parseErr != nil {
			return nil, gqlErr(ctx, parseErr)
		}
		opts.Since = &t
	}
	entries, hasMore, err := r.AuditStore.QueryAudit(ctx, tid, opts)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	gqlEntries := make([]*AuditEntry, len(entries))
	for i := range entries {
		gqlEntries[i] = auditToGQL(&entries[i])
	}
	return &AuditConnection{Entries: gqlEntries, HasMore: hasMore}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
