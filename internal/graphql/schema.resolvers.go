package graphql

// Code generated by github.com/99designs/gqlgen version v0.17.86
// Resolver implementations below are hand-written.
// Mutation resolvers are in mutation.resolvers.go.

import (
	"context"
	"time"

	"github.com/persistorai/persistor/internal/models"
)

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (*Node, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	n, err := r.NodeSvc.GetNode(ctx, tid, id)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodeToGQL(n), nil
}

// Nodes is the resolver for the nodes field.
func (r *queryResolver) Nodes(ctx context.Context, typeArg *string, minSalience *float64, limit *int, offset *int) (*NodeConnection, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	nodes, hasMore, err := r.NodeSvc.ListNodes(ctx, tid, derefStr(typeArg), deref(minSalience, 0.0), deref(limit, 50), deref(offset, 0))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &NodeConnection{Nodes: nodesToGQL(nodes), HasMore: hasMore}, nil
}

// Edges is the resolver for the edges field.
func (r *queryResolver) Edges(ctx context.Context, source *string, target *string, relation *string, limit *int, offset *int) (*EdgeConnection, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	edges, hasMore, err := r.EdgeSvc.ListEdges(ctx, tid, derefStr(source), derefStr(target), derefStr(relation), deref(limit, 50), deref(offset, 0))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &EdgeConnection{Edges: edgesToGQL(edges), HasMore: hasMore}, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, limit *int) ([]*SearchResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	nodes, err := r.SearchSvc.FullTextSearch(ctx, tid, query, "", 0, deref(limit, 20))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodesToSearchResults(nodes), nil
}

// SearchSemantic is the resolver for the searchSemantic field.
func (r *queryResolver) SearchSemantic(ctx context.Context, query string, limit *int) ([]*SearchResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	scored, err := r.SearchSvc.SemanticSearch(ctx, tid, query, deref(limit, 20))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return scoredNodesToSearchResults(scored), nil
}

// SearchHybrid is the resolver for the searchHybrid field.
func (r *queryResolver) SearchHybrid(ctx context.Context, query string, limit *int) ([]*SearchResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	nodes, err := r.SearchSvc.HybridSearch(ctx, tid, query, deref(limit, 20))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodesToSearchResults(nodes), nil
}

// Neighbors is the resolver for the neighbors field.
func (r *queryResolver) Neighbors(ctx context.Context, id string, limit *int) (*NeighborResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	result, err := r.GraphSvc.Neighbors(ctx, tid, id, deref(limit, 50))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &NeighborResult{Nodes: nodesToGQL(result.Nodes), Edges: edgesToGQL(result.Edges)}, nil
}

// Traverse is the resolver for the traverse field.
func (r *queryResolver) Traverse(ctx context.Context, id string, maxHops *int) (*TraverseResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	result, err := r.GraphSvc.Traverse(ctx, tid, id, deref(maxHops, 2))
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &TraverseResult{Nodes: nodesToGQL(result.Nodes), Edges: edgesToGQL(result.Edges)}, nil
}

// Context is the resolver for the context field.
func (r *queryResolver) Context(ctx context.Context, id string) (*ContextResult, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	result, err := r.GraphSvc.GraphContext(ctx, tid, id)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return &ContextResult{
		Node:      nodeToGQL(&result.Node),
		Neighbors: nodesToGQL(result.Neighbors),
		Edges:     edgesToGQL(result.Edges),
	}, nil
}

// Path is the resolver for the path field.
func (r *queryResolver) Path(ctx context.Context, from string, to string) ([]*Node, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	nodes, err := r.GraphSvc.ShortestPath(ctx, tid, from, to)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	return nodesToGQL(nodes), nil
}

// Audit is the resolver for the audit field.
func (r *queryResolver) Audit(ctx context.Context, entityType *string, entityID *string, action *string, since *string, limit *int, offset *int) (*AuditConnection, error) {
	tid, err := TenantIDFromContext(ctx)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	opts := models.AuditQueryOpts{
		EntityType: derefStr(entityType),
		EntityID:   derefStr(entityID),
		Action:     derefStr(action),
		Limit:      deref(limit, 50),
		Offset:     deref(offset, 0),
	}
	if since != nil {
		t, parseErr := time.Parse(time.RFC3339, *since)
		if parseErr != nil {
			return nil, gqlErr(ctx, parseErr)
		}
		opts.Since = &t
	}
	entries, hasMore, err := r.AuditSvc.QueryAudit(ctx, tid, opts)
	if err != nil {
		return nil, gqlErr(ctx, err)
	}
	gqlEntries := make([]*AuditEntry, len(entries))
	for i := range entries {
		gqlEntries[i] = auditToGQL(&entries[i])
	}
	return &AuditConnection{Entries: gqlEntries, HasMore: hasMore}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
